#!/usr/bin/env node
'use strict';

const { MongoClient } = require('../..');
const visualizeMonitoringEvents = require('./utils').visualizeMonitoringEvents;
const chalk = require('chalk');
const argv = require('yargs')
  .usage('Usage: $0 [options] <connection string>')
  .demandCommand(1)
  .help('h')
  .describe('workload', 'Simulate a read workload')
  .describe('legacy', 'Use the legacy topology types')
  .alias('l', 'legacy')
  .alias('w', 'workload')
  .alias('h', 'help').argv;

function print(msg) {
  console.log(`${chalk.white(new Date().toISOString())} ${msg}`);
}

const uri = argv._[0];
const client = new MongoClient(uri, {
  useNewUrlParser: true,
  useUnifiedTopology: !argv.legacy
});

let workloadInterrupt = false;
async function run() {
  print(
    `connecting to: ${chalk.bold(uri)} using ${chalk.bold(
      argv.legacy ? 'legacy' : 'unified'
    )} topology`
  );

  visualizeMonitoringEvents(client);
  await client.connect();

  if (argv.workload) {
    while (!workloadInterrupt) {
      await wait(2000);

      try {
        print(`${chalk.yellow('workload')} issuing find...`);
        const result = await client
          .db('test')
          .collection('test')
          .find({})
          .limit(1)
          .toArray();
        print(`${chalk.yellow('workload')} find completed: ${JSON.stringify(result)}`);
      } catch (e) {
        print(`${chalk.yellow('workload')} find failed: ${e.message}`);
      }
    }
  }
}

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

run().catch(error => console.log('Caught', error));
process.on('SIGINT', async function() {
  workloadInterrupt = true;
  await client.close();
});
